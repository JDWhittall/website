<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Game Library</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="gameliststyle.css">
</head>
<body>
  <header>
    <h1>Game Library</h1>
    <nav>
      <a href="addowner.html">Add New Profile</a>
      <a href="addnewgame.html">Add New Game</a>
    </nav>
  </header>

  <main>
    <section id="controls">
      <label>
        Owner:
        <select id="owner-filter">
          <option value="">All owners</option>
        </select>
      </label>

      <label>
        Search:
        <input id="search-input" type="search" placeholder="Name, genre, notes…">
      </label>

      <label>
        Players:
        <span class="player-filter">
          <input id="players-max" type="number" min="1" inputmode="numeric" placeholder="Max">
        </span>
      </label>

      <button id="clear-filters" type="button">Clear filters</button>
    </section>

    <div id="games-status">Loading games…</div>
    <section id="games-list" class="game-grid"></section>
	<pre id="output"></pre>

  </main>

  <script>
const BASE_URL = "https://script.google.com/macros/s/AKfycbxURFaWZ8gz-TZ-Jtep-4zkOiKK95bobxKaCDgfzQU0kPmn3QFKZj24cO6x2BXImM2U8w/exec";

let ownersMap = new Map();
let gamesCache = [];
let expansionsMap = new Map();
let baseGames = [];

const filters = {
  search: "",
  owner: "",
  maxPlayers: null
};

const elements = {
  status: document.getElementById("games-status"),
  list: document.getElementById("games-list"),
  search: document.getElementById("search-input"),
  ownerFilter: document.getElementById("owner-filter"),
  playersMax: document.getElementById("players-max"),
  clearBtn: document.getElementById("clear-filters")
};

function normalizeName(name) {
  return (name || "").trim().toLowerCase();
}
 
function getParentName(game) {
  return (game.expansionOf || game.ExpansionOf || "").trim();
}

async function fetchOwners() {
  const res = await fetch(`${BASE_URL}?type=owners`);
  return res.json();
}

async function fetchGames() {
  const res = await fetch(BASE_URL, { method: "GET" });
  return res.json();
}

function populateOwnerFilter(owners) {
  const select = elements.ownerFilter;
  select.innerHTML = `<option value="">All owners</option>`;
  owners.forEach((owner) => {
    const name = (owner.name || "").trim();
    if (!name) return;
    const opt = document.createElement("option");
    opt.value = name;
    opt.textContent = name;
    select.appendChild(opt);
  });
}

function renderOwners(rawOwners, ownersMap) {
  const names = (rawOwners || "")
    .split(",")
    .map((n) => n.trim())
    .filter(Boolean);

  if (!names.length) {
    return `<span class="owner-chip owner-chip--missing" title="Owner unknown"><span class="owner-initial">?</span></span>`;
  }

  return names
    .map((name) => {
      const avatar = ownersMap.get(name.toLowerCase());
      const initial = (name.charAt(0) || "?").toUpperCase();
      if (avatar) {
        return `
          <span class="owner-chip owner-chip--avatar" title="${name}">
            <img src="${avatar}" alt="${name} avatar" onerror="this.onerror=null; this.style.display='none'; const p=this.parentElement; p.className='owner-chip owner-chip--missing'; p.innerHTML='<span class=\\'owner-initial\\'>${initial}</span>'">
          </span>`;
      }
      return `<span class="owner-chip owner-chip--missing" title="${name}"><span class="owner-initial">${initial}</span></span>`;
    })
    .join("");
}

function parsePlayersRange(playersValue) {
  const numbers = String(playersValue || "").match(/\d+/g);
  if (!numbers || !numbers.length) return null;
  const nums = numbers.map((n) => Number(n)).filter((n) => !Number.isNaN(n));
  if (!nums.length) return null;
  return {
    min: Math.min(...nums),
    max: Math.max(...nums)
  };
}

function matchesFilters(game) {
  // Owner filter
  if (filters.owner) {
    const ownersList = (game.owners || "")
      .split(",")
      .map((n) => normalizeName(n))
      .filter(Boolean);
    if (!ownersList.includes(normalizeName(filters.owner))) {
      return false;
    }
  }

  // Search filter
  if (filters.search) {
    const haystack = [
      game.gameName,
      game.description,
      game.genre,
      game.notes,
      game.owners
    ]
      .map((v) => (v || "").toLowerCase())
      .join(" ");
    if (!haystack.includes(filters.search)) {
      return false;
    }
  }

  // Player range filter
  const hasPlayerFilter = filters.maxPlayers !== null;
  if (hasPlayerFilter) {
    const range = parsePlayersRange(game.players || game.playerCount || "");
    if (!range) {
      return false;
    }
    if (range.max < filters.maxPlayers) {
      return false;
    }
    if (range.min > filters.maxPlayers) {
      return false;
    }
  }

  return true;
}

function renderGames() {
  elements.list.innerHTML = "";

  // Filter base games to include those where either the base or one of its expansions matches
  const filteredBase = baseGames.filter((base) => {
    const baseMatches = matchesFilters(base);
    const exps = expansionsMap.get((base.gameName || '').trim()) || [];
    const anyExpMatches = exps.some((e) => matchesFilters(e));
    return baseMatches || anyExpMatches;
  });

  if (!filteredBase.length) {
    elements.status.textContent = "No games match these filters.";
    return;
  }

  elements.status.textContent = "";

  filteredBase.forEach((item) => {
    const card = document.createElement("div");
    card.className = "game-card";

    card.innerHTML = `
  <div class="cover-div">
    <img src="${item.imageUrl}"
         class="game-cover"
         alt="Cover image for ${item.gameName}">
  </div>

  <div class="game-description">
    <h2>${item.gameName}</h2>
    <p>${item.description}</p>
    <div class="game-info">
      <span><img src="images/players.png" style="height:1.5rem; width:auto;"><span style="vertical-align: top;"> ${item.players} players</span></span>
      <span style="vertical-align: top;margin-left:1rem;margin-right:1rem;"> | </span>
      <span><img src="images/timer.png" style="height:1.5rem; width:auto;"><span style="vertical-align: top;"> ${item.playtime} minutes</span></span>
    </div>
    <div class="other-info">
      ${item.scoreSheet ? `<a href="${item.scoreSheet}" target="_blank" rel="noopener">Score Sheet</a>` : ""}
      <div class="owner-list">${renderOwners(item.owners, ownersMap)}</div>
    </div>
    
  </div>
`;

    // Create expansions container (hidden by default)
    const exContainer = document.createElement('div');
    exContainer.className = 'expansions-container';

    const exList = (expansionsMap.get((item.gameName || '').trim()) || []).filter(matchesFilters);
    exList.forEach((exp) => {
      const exCard = document.createElement('div');
      exCard.className = 'game-card expansion-card';
      exCard.innerHTML = `
        <div class="cover-div">
          <img src="${exp.imageUrl}" class="game-cover expansion" alt="Expansion cover for ${exp.gameName}">
        </div>
        <div class="game-description">
          <h3>${exp.gameName}</h3>
          <div class="meta">${exp.description || ''}</div>
        </div>
      `;
      exContainer.appendChild(exCard);
    });

    card.addEventListener('click', (e) => {
      // Don't toggle when clicking links
      if (e.target.tagName.toLowerCase() === 'a') return;
      exContainer.classList.toggle('show');
    });

    elements.list.appendChild(card);
    elements.list.appendChild(exContainer);
  });
}

async function loadGames() {
  elements.status.textContent = "Loading games...";

  try {
    const [owners, games] = await Promise.all([fetchOwners(), fetchGames()]);

    ownersMap = new Map(
      owners.map((o) => [normalizeName(o.name), o.avatarUrl || ""])
    );

    populateOwnerFilter(owners);
    gamesCache = games || [];

    // Build expansions map and baseGames list defensively: only treat a row as an
    // expansion when its ExpansionOf matches an existing game name.
    const nameSet = new Set((gamesCache || []).map(g => normalizeName(g.gameName)));
    expansionsMap = new Map();
    baseGames = [];
    gamesCache.forEach((g) => {
      const parent = getParentName(g);
      const parentNorm = normalizeName(parent);
      if (parent && nameSet.has(parentNorm)) {
        const parentObj = gamesCache.find(x => normalizeName(x.gameName) === parentNorm) || { gameName: parent };
        const key = (parentObj.gameName || parent).trim();
        if (!expansionsMap.has(key)) expansionsMap.set(key, []);
        expansionsMap.get(key).push(g);
      } else {
        baseGames.push(g);
      }
    });

    console.log('Loaded games:', gamesCache);
    console.log('Expansions map keys:', Array.from(expansionsMap.keys()));

    renderGames();
  } catch (err) {
    elements.status.textContent = "Error loading data";
    console.error(err);
  }
}

elements.search.addEventListener("input", (e) => {
  filters.search = e.target.value.toLowerCase();
  renderGames();
});

elements.ownerFilter.addEventListener("change", (e) => {
  filters.owner = e.target.value;
  renderGames();
});

function setPlayerFilter(which, value) {
  const num = Number(value);
  filters[which] = Number.isNaN(num) || value === "" ? null : num;
  renderGames();
}

elements.playersMax.addEventListener("input", (e) =>
  setPlayerFilter("maxPlayers", e.target.value)
);

elements.clearBtn.addEventListener("click", () => {
  filters.search = "";
  filters.owner = "";
  filters.maxPlayers = null;

  elements.search.value = "";
  elements.ownerFilter.value = "";
  elements.playersMax.value = "";

  renderGames();
});

window.onload = loadGames;
  </script>
</body>
</html>
